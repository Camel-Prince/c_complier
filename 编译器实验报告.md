# 编译器实验报告
[编译器github项目地址](https://github.com/Camel-Prince/c_complier.git)
## 成员分工
### 王子旭（组长，学号1813033）

 1. 词法分析：第一个版本；

 2. 语法分析：创建抽象语法树的工具类；生成四则运算和赋值表达式的语法树；

 3. 中间代码：四元式的工具类；生成四则运算和赋值表达式的中间代码；

 4. 创建符号表并管理符号表相关的内容；

 5. 一维指针和一维数组的中间代码生成；

 6. 错误处理：变量未定义、变量重定义；

 7. 类型检查：指针和整型变量之间赋值时会有warning;

 8. 中间代码的优化：只定义而未使用变量不会被生成中间代码；

###  马澜轩
1. 部分文法

2. 中间代码生成：生成部分控制流语句、逻辑运算和关系运算的中间代码
###  仲玲叶
1. 部分语法分析：写测试文件，测试最后的生成树

2. 汇编部分：
### 辛昊洋
1. 部分语法分析：生成逻辑运算和for控制流语句等的语法树部分

2. 部分中间代码生成：生成控制流语句for的中间代码

3. 尝试实现中间代码优化（未果）

4. 实验报告编撰整合

~~-----------------------------------------------------------------------------------------------------------------~~ 
## 项目架构
**文件夹abstract_syntax_tree：**

生成抽象语法树的工具类，主要包括：节点类和节点类型的枚举；

**文件夹asm：**

**AsmGenerate&AsmCode（包括.h和.cpp）：**

在parser.y中传入四元式组，调用`AsmGenerate`类中的构造函数，保证参数的传入。
然后调用函数`generate`，开始生成汇编指令。

首先将必要的文件开头加入保存的字符串中，然后根据`goto`指令修改四元式组，再根据每个四元式的类型进入对应的处理函数，生成相关汇编指令。每个函数中又对四元式参数的类型有区分，这样就可以同时处理`symbol`类型和整型的数据。
处理完之后，保存的字符串中也有很多行代码了，这些代码就是需要写到`asm`文件中的汇编指令。
在最后加上必要的退出语句后就可以将其写入`asm`文件中，然后保存关闭。


asm_io.asm：

> 最后要执行的`asm`文件，文件开头的一些指令是一些可以调用的函数，在汇编生成成功后文件最后会多出若干行代码，使用`asm`执行这些文件，既可以得到对应的输出。


**文件夹intermediate_code：**

用于生成四元式的工具类；主要包括：四元式操作符的枚举、四元式参数的联合以及四元式项的类和中间代码的类；

**文件夹symbol_table:**

用于创建和管理符号表；主要包括：符号类型的枚举、符号的类以及符号表的类；

Scanner.l：

> 为lex文件，用于词法分析；

Parser.y：

> 为yacc文件，主要用于用于语法分析，其第三部分的main函数是整个项目的入口和主体，依次完成文件读入、词法分析、语法分析（抽象语法树的生成）、中间代码生成以及汇编程序的生成，并运行得到的汇编程序；

**运行方式：**
1. 进入项目目录在终端输入`make`指令
2. 在linux系统下，`make`之后会得到可执行文件scanner_parser_test
3. 在mac下则会出现问题，此时需要在`parser.tab.h`文件的前两行输入以下代码：

```c
#include "abstract_syntax_tree/AstNode.h
#include "symbol_table/symbol.h
#include "intermidiate_code/interCode.h 
#include "asm/AsmCode.h  #include "asm/AsmGenerate.cpp" 
```

 
 保存后在终端输入命令:

`g++ -o scanner_parser_test AstNode.o symbol.o interCode.o AsmGenerate.o parser.tab.c scanner.lex.c`

3. 执行`scanner_parser_test`，若没有参数则会读取标准终端输入；或者提供文件路径来读取文件的内容，对文件进行词法、语法分析,以及中间代码、汇编语言的生成；
4.  注意`make clean`后再进行编译执行；
5. 注意，数组名和变量名不应该冲突；
6. 在虚拟机上面`make` ，就可以从头到尾一起执行。

~~-----------------------------------------------------------------------------------------------------------------~~ 
## 主要思路

**1. 词法分析器：**

> 借助lex工具，定义所用到的终结符即可；

**2. 语法分析器：**

生成语法树部分：

> 采用长子-兄弟的结构来构造语法树；
> 每个节点保存该节点的类型和内容；
> 在规约时进行节点的构建和节点之间的连接；
> 生成语法树后对它进行深度优先遍历，并规定输出格式即可完成语法树的生成和输出；

四则运算和赋值表达式的语法树构建：

> 根据设计好的文法来使用语法树的工具类即可；

生成某个具体的控制流语句的语法树，对语法树进行遍历。下面以if语句为例具体介绍：

>（1）if语句：判断节点内容若为if_stmt,使用exp_generate对if语句的第一个孩子进行处理，生成两条的四元式，一条为真时的跳转，一条为假时的跳转，将其压入quad_list；处理完条件后对body部分进行处理，按顺序将生成的四元式放入quad_list，在输出时根据四元式的操作对应格式输出。

>（2）if-else语句：若节点内容为if_else_stmt，处理方法大体同if语句，但在处理else的部分时，加入新的符号表子表，使用backpatch回填函数将quad_list语句中对应true和false的四元式的跳转目标分别设为body块在quad_list中对应的的起始下标。

>（3）for与while的过程与if语句基本相同，只需要将在处理body时对子表循环操作。

语法生成树的测试：

> 先写一个比较简单的测试文件，然后试试看能不能运行出全部的语法树；

>   如果有问题再根据代码逻辑找到对应的部分，逐条语句复查；

> 等这一部分最基础的语句实现了之后就依次增加语句的复杂度，最后能生成各种语句的语法树；

      
 **3. 中间代码生成：**

   采用四元式来作为中间代码；
      
   构建一个类（Quad）来管理单条四元式，再构建一个类（InterCode）来根据扫描语法树以递归的方式建立并管理四元式序列；
      
   创建四元式序列：

>    主要依靠语法树中节点的类型和内容；
其中四则运算和赋值表达式的中间代码生成按照上述思想，并结合相应的语法树结构即可完成；
      
   
**4.逻辑运算与关系运算：**

这两种运算为布尔表达式，涉及跳转过程，因为其操作主要部分都是jump。以关系运算为例具体介绍:

> （1）若节点操作为关系运算，新建内容并加入符号表中，生成两条四元式，91对应true的一条有四个内容，分别是arg1 arg2 result和optype,对应false的一条仅有两个内容，result和jump，将两条四元式压入quad_list。

> （2）逻辑运算是在关系运算基础上的。此时需要维护两个栈，一个存放true的四元式，一个存放false的四元式，使用merge函数将两个关系运算进行合并，在“或”的基础上，只需要其中一个为true,在“与”的基础上需要所有关系运算都为true才可以。




  **5. 符号表的创建和管理：**

符号表代表着一个作用域；

构建一个类（Symbol）：

> 来表示单个变量的信息，如名字、类型和在符号表中的偏移量等；

再构建一个类（SymbolTable）：

> 用来存放一个作用域中的所有符号信息；

符号表之间的关系：

> 采用长子-兄弟的方法来构建树并在进行中间代码生成时完成创建；

所有的和整型以及指针、数组变量相关的中间代码生成：

> 需要引入符号表的创建、维护、查找等功能；

 **6. 一维数组和一维指针的中间代码：**

四元式的格式和创建：

> 需要根据语法树的对应局部来完成；

符号表相关内容则需要谨慎考虑偏移量的问题：

> 数组变量在定义时就可以根据长度和数组元素类型来确定偏移量；
>  而指针则只有在指向某个变量后才会确定偏移量；

**7. 错误处理：**

变量未定义：

> 在创建四元式前从符号表中查找四元式用到的变量是否存在于表中，如果在本符号表和上层的所有表中都不存在，那么报变量未定义的错误；

变量重定义：

> 在变量定义，如果在本符号表中找到同名、同类型的变量则报变量重定义的错误；

**8. 汇编部分：**

> 尝试完成最简单的代数运算，赋值、加减乘除等，这些也是中间代码部分过来的最基本的格式；

> 在中间代码部分，已经知道各个变量的偏移量，所以可以在栈中根据偏移量把这个变量放到对应的位置，这样就可以实现基本的赋值、取值功能；

> 然后使用寄存器进行加减乘除；

> 涉及到语句的跳转就要使用label，传入的四元式组已经固定，那就需要在四元组里面再加若干个四元组用于表示特殊的label；

> 传入四元式后先处理四元式组，得到新的组，然后在对每个四元式分析的时候碰到label段就加入label标志，这样就可以指引跳转目标；

 **9. 类型检查：**
 

> 在赋值运行时，检查result和arg1的类型是否匹配，如果不匹配则报相应的类型不匹配警告；

**10. 代码优化：**

> 在生成四元式序列时，标记符号表中的变量是否被使用； 
> 在生成四元式序列后遍历之，删除未使用变量的定义四元式。

~~-----------------------------------------------------------------------------------------------------------------------~~ 
## 实验总结


**遇到的困难与解决方法：**

1. for语句情况较多，用一个产生式体识别会给语义动作的添加带来麻烦。

> 分别用不同的产生式体识别for语句的每一种可能情况。

2. 需要将汇编语句写入到asm文件中，所以在汇编部分用字符串变量保存当前的语句，直到执行完所有的中间代码后用c++的读写流写入到文件中。但是并没有找到覆盖指定部分的办法。

> 手动修改asm文件中另外加入的部分。
3. 运行最基本的语句。
> 用栈来存储变量所以在开头加上语句push ebx  mov ebp,esp，以及最后加上pop ebxret保证可以正常退出以及防止core dumped。一开始因为没有写print语句，所以测试的时候都是手动将数据移到eax寄存器中，然后执行echo来显示结果的。
4. 做基础运算时：
中间代码部分对数据的处理不够充分，导致不同的运算方式没有被成功区分开来。
> 对所有的语句格式进行了梳理，将基本格式按顺序分类并标号，在汇编中就可以利用标号找到对应的符号。
5. 做控制流语句时：
> 一开始也只能手动加label标记来保证正确执行程序，为解决程序加label的问题想了两种解决办法：一种是在涉及到goto target的四元式后分别加label进行标记，另外一种是修改一开始的四元式组。
> 在了解其基本原理后决定对一开始输入的四元式进行修改，判断到有goto就在它之前加一个单独的label标志，大大减少了工作量，也让代码更加清晰。


